12:52 AM <locks> alexgordon: tell me one mutton function to implement
12:52 AM <alexgordon> mmm
12:52 AM <alexgordon> what's on the wishlist?
12:52 AM <locks> I might need a distraction tomorrow
12:52 AM <alexgordon>
https://github.com/fileability/mutton/blob/master/wishlist.txt
12:52 AM <alexgordon> haha
12:52 AM <alexgordon> locks: how about commonest
12:52 AM <alexgordon> return an array of the most commonly occuring
values
12:52 AM ⇐ zml2008 (~SGC@c-24-22-98-123.hsd1.or.comcast.net) quit: Read
error: Connection reset by peer
12:52 AM <locks> alexgordon: oh, did you see my link to underscore.objc?
12:53 AM <alexgordon> nope
12:53 AM <locks> https://github.com/petejkim/underscore.objc
12:53 AM <locks> it's basically the inverse of mutton
12:53 AM <alexgordon> this is more like prelude.objc though :P
12:53 AM <alexgordon> (mutton is)
12:54 AM <alexgordon> locks: yeah try doing commonest
12:54 AM <alexgordon> so like
12:55 AM <alexgordon> commonest(@[@"a", @"b", @"c", @"b", @"c"]) -->
@[@"b", @"c"]
12:55 AM <alexgordon> actually, do commonestBy and use that to implement
commonest
12:56 AM <locks> what's commonestBy interface?
12:56 AM <alexgordon> NSArray* commonestBy(Iter it, BinaryPredicate eq);
12:56 AM <locks> so, hm, I count how many times each element occurs
12:56 AM <alexgordon> basically it uses eq(a, b) instead of [a
isEqual:b] like commonest
12:56 AM <locks> and return however many there are of the max value
12:57 AM <alexgordon> no
12:57 AM <alexgordon> return the most common elements
12:57 AM <alexgordon> @[@"b", @"c"]
12:57 AM <locks> that's what I meant
12:57 AM <locks> like, b and c both repeat 2 times
12:57 AM <alexgordon> right
12:57 AM <locks> that the "max value"
12:57 AM <locks> ok
12:57 AM <alexgordon> yeah not sure how to do it :P
12:58 AM <alexgordon> I'd say use NSCountedSet
12:58 AM <alexgordon> but, won't work for commonestBy
12:58 AM <alexgordon> might be good for commonest if we wanted to do a
specialization
12:58 AM <locks> I'll figure something, I guess
12:59 AM <locks> bubye o/
12:59 AM <alexgordon> yeaaaah this is going to be O(n^2)
12:59 AM <alexgordon> bye
12:59 AM <alexgordon> locks: oh atually
1:00 AM <alexgordon> easy
1:00 AM <alexgordon> sort the list
1:00 AM <alexgordon> duh
1:00 AM <locks> haha :P
New messages
1:00 AM <alexgordon> then count runs
1:00 AM <alexgordon> 'night
1:01 AM ⇐ ramitos (~ramitos@bl22-29-148.dsl.telepac.pt) quit
1:04 AM <alexgordon> locks: oh if you're still there, another useful function would be to get a list of lists of N consequitive elements
